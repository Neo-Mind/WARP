/**************************************************************************\
*                                                                          *
*   Copyright (C) 2013-2022 Neo-Mind                                       *
*                                                                          *
*   This file is a part of WARP project (specific to RO clients)           *
*                                                                          *
*   WARP is free software: you can redistribute it and/or modify           *
*   it under the terms of the GNU General Public License as published by   *
*   the Free Software Foundation, either version 3 of the License, or      *
*   (at your option) any later version.                                    *
*                                                                          *
*   This program is distributed in the hope that it will be useful,        *
*   but WITHOUT ANY WARRANTY; without even the implied warranty of         *
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          *
*   GNU General Public License for more details.                           *
*                                                                          *
*   You should have received a copy of the GNU General Public License      *
*   along with this program.  If not, see <http://www.gnu.org/licenses/>.  *
*                                                                          *
*                                                                          *
|**************************************************************************|
*                                                                          *
*   Author(s)     : Neo-Mind                                               *
*   Created Date  : 2020-11-18                                             *
*   Last Modified : 2022-08-24                                             *
*                                                                          *
\**************************************************************************/

///
/// \brief Finds the MsgStringTable address and extracts all the strings
///        till the end into output file. Also allows for translations using a
///        mapping file (similar to the one used in Translate Client patch)
///
ExtractMsgStrings = function()
{
	const _ = 'ExtractMsgStrings : ';

	$$(_ + '1.1 - Need a valid Exe loaded')
	if (Exe.FileSize === 0)
		throw NO_EXE;

	$$(_ + '1.2 - Find the string \'msgStringTable.txt\'')
	let addr = Exe.FindText("msgStringTable.txt", CASE_INSENSITIVE);
	if (addr < 0)
		throw Error("'msgStringTable.txt' not found");

	$$(_ + '1.3 - Find where its used in a PUSH')
	addr = Exe.FindHex(PUSH(addr) + PUSH()); //push offset "msgStringTable.txt"
	                                         //push <const>
	if (addr < 0)
		throw Error("'msgStringTable.txt' not used");

	ShowAddr(addr);
	$$(_ + '1.4 - Find the message string table reference after/before it')
	let code, addr2;
	if (Exe.Version < 9.0) //VC6
	{
		code =
			XOR(ESI, ESI)    //xor esi, esi
		+	MOV(R32, POS3WC) //mov regA, offset
		;
		addr2 = Exe.FindHex(code, addr + 10, addr + 0x20);
	}
	else if (Exe.Version < 14.0) //VC9-VC11
	{
		code =
			XOR(R32, R32)           //xor regA, regA
		+	XOR(R32, R32)           //xor regB, regB
		+	MOV(R32, R32)           //mov regC, regD
		+	MOV(R32, [R32, POS3WC]) //mov regE, dword ptr [regC + dispC]
		;

		addr2 = Exe.FindHex(code, addr - 0x40, addr);
	}
	else  //VC14.16
	{
		code =
			XOR(R32, R32)           //xor regA, regA
		+	XOR(R32, R32)           //xor regB, regB
		+	NOP2                    //2 byte nop
		+	MOV(EAX, [POS4WC])      //mov eax, dword ptr [offset#1]
		+	LEA(R32, [R32, 4])      //lea regC, [regD+4]
		+	MOV(R32, [R32, POS4WC]) //mov regE, dword ptr [regC + dispC]
		;

		addr2 = Exe.FindHex(code, addr - 0x40, addr);
		if (addr2 < 0 && Exe.BuildDate > 20220000)
		{
			code =
				PUSH_R                  //push regA
			+	XOR(R32, R32)           //xor regA, regA
			+	MOV(R32, POS4WC)        //mov regB, offset#1
			;
		
			addr2 = Exe.FindHex(code, addr - 0x40, addr);
		}
	}
	if (addr2 < 0)
		throw Error("Message string LUT missing");

	$$(_ + '1.5 - Extract the table address (PHYSICAL one)')
	const disp = Exe.GetUint32(addr2 + code.byteCount() - 4);
	addr = Exe.Vir2Phy(disp - 4);

	$$(_ + '2.1 - Get the mapping file from user')
	const inFile = Exe.GetUserInput("$$msgTranslations", D_InFile, "MsgString Translations", "Enter translation mapping file (Optional)", "Inputs/MsgStrMap_EN.yml");

	$$(_ + '2.2 - Load the translation mapping if valid file provided')
	const trMap = inFile ? this.loadTr(inFile) : null;

	$$(_ + '3.1 - Open output file for writing (Need ASCII encoding)')
	const outFile = Exe.GetUserInput("$$msgStrTable", D_OutFile, "Target File", "Enter the target file path", OUTDIR + "msgStringTable_" + ROC.BaseName + ".txt");
	if (outFile === false)
		return true;

	let fp = new TextFile(outFile, ASCII, 'w');
	if (!fp.Valid)
		throw NO_OUTPUT;

	$$(_ + '3.2 - Stop when the int32 at current Location is not matching current index')
	for (let idx = 0; Exe.GetUint32(addr) === idx; idx++, addr += 8)
	{
		const __ = `${_} [${idx}] `;

		$$(__ + '3.3 - Get the address of the string')
		const strAddr = Exe.Vir2Phy(Exe.GetUint32(addr + 4));

		$$(__ + '3.4 - Extract the string')
		let msgStr = Exe.GetText(strAddr);

		$$(__ + '3.5 - Translate the string if mapping available, otherwise just escape the backslash in \n and \r')
		if (trMap && trMap.has(msgStr))
			msgStr = trMap.get(msgStr);
		else
			msgStr = msgStr.replace(/\n/g, '\\n').replace(/\r/g, '\\r');

		$$(__ + '3.6 - Write into output file')
		fp.WriteLine(msgStr + '#');
	}

	$$(_ + '3.7 - Close the file')
	fp.Close();

	$$(_ + '4  - Show the success message or display the file if requested')
	if (!Warp.TestMode && UserChoice("Show File", "Display the generated file?"))
	{
		Warp.Show(fp.Path);
		return true;
	}
	else
	{
		return "MsgStrings have been extracted";
	}
};

///
/// \brief Helper function for loading translation YAML into 1 to 1 mapping
///
ExtractMsgStrings.loadTr = inFile =>
{
	const _ = "ExtractMsgStrings.loadTr : ";

	$$(_ + '1.1 - Load the YAML file (need it to be an array)')
	const arr = Warp.LoadYaml(inFile);
	if (!Array.isArray(arr))
		return null;

	$$(_ + '1.2 - Initialize the map')
	let trMap = new Map();
	for (const hash of arr)  //iterate through the array
	{
		$$(_ + '1.3 - Retrieve the \'find\' and \'replace\' values.')
		let {find: findPat, replace: replStr} = hash;

		if (!findPat || !replStr)
			continue;

		$$(_ + '1.4 - Processing ' + findPat);
		findPat = findPat.toString().replace(/\n/g, "\\n").replace(/\r/g, "\\r");
		replStr = replStr.toString().replace(/\n/g, "\\n").replace(/\r/g, "\\r");

		$$(_ + '2.1 - If the pattern is a hex then convert to equivalent bytes, otherwise just extract the data within')
		let result = findPat.match(/^\s*<(.*)>\s*$/);
		if (result)
			findPat = result[1].toAscii();

		$$(_ + '2.2 - Repeat same for replacement string')
		result = replStr.match(/^\s*<(.*)>\s*$/);
		if (result)
			replStr = result[1].toAscii();

		$$(_ + '2.3 - Add to the map')
		trMap.set(findPat, replStr);
	}

	return trMap;
};
