/**************************************************************************\
*                                                                          *
*   Copyright (C) 2020-2021 Neo-Mind                                       *
*                                                                          *
*   This file is a part of WARP project (specific to RO clients)           *
*                                                                          *
*   WARP is free software: you can redistribute it and/or modify           *
*   it under the terms of the GNU General Public License as published by   *
*   the Free Software Foundation, either version 3 of the License, or      *
*   (at your option) any later version.                                    *
*                                                                          *
*   This program is distributed in the hope that it will be useful,        *
*   but WITHOUT ANY WARRANTY; without even the implied warranty of         *
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          *
*   GNU General Public License for more details.                           *
*                                                                          *
*   You should have received a copy of the GNU General Public License      *
*   along with this program.  If not, see <http://www.gnu.org/licenses/>.  *
*                                                                          *
*                                                                          *
|**************************************************************************|
*                                                                          *
*   Author(s)     : Neo-Mind                                               *
*   Created Date  : 2020-11-06                                             *
*   Last Modified : 2021-07-22                                             *
*                                                                          *
\**************************************************************************/

if (typeof LUA === 'undefined') // avoid redefinition
{
	///
	/// \brief Values denoting how to call the Allocator function
	///
	FnMode = {
		Regular: 0, //Regular DIRECT call
		Ptr: 1,     //INDIRECT call using a memory ptr
		ZInit: 2,   //DIRECT call with a zero initialization first
		Unknown: 3  //Self Explanatory
	};

	IdentifyObj("FnMode");

	///
	/// \brief Hash describing the Lua Interface details
	///
	LUA =
	{
		///
		/// \brief Initialize the data members
		///
		init : function()
		{
			this.ReqJN     = -1;   //The VIRTUAL address of "ReqJobName"
			this.PushRJN   = '';   //The code for PUSH OFFSET addr; ASCII "ReqJobName"
			this.PushState = '';   //The code for PUSH dword ptr [GlobLuaState]
			this.StkConst  = 0;    //The constant value used in SUB ESP, const which gets executed before Lua Function name is PUSHed
			this.Allocator = -1;   //The VIRTUAL address of the function which allocates space to store the Lua function name

			this.Al_Mode = FnMode.Unknown; //The mode of the allocator function above

			this.FnInvoker  = -1;  //The VIRTUAL address of the function which invokes the "Lua function" already PUSHed as argument
			this.FileLoader = -1;  //The VIRTUAL address of the function which loads the Lua file already PUSHed as argument

			this.FL_movECX  = '';  //The code for MOV ECX, dword ptr [addr] ; where addr evaluates to GlobLuaState
			                       //Used before CALLs to FileLoader

			delete this.Pushers;   //Map of various PUSH codes for formats like "d>s"
			delete this.Valid;     //Will be true or false indicating extraction status
			delete this.Error;     //Error Object containing a message about the issue encountered during extraction if any

			IdentifyObj("LUA");
		},

		///
		/// \brief Extracts the new data from a loaded exe.
		///
		load : function()
		{
			const _ = "LUA.load : ";

			$$(_ + '1.1 - Check if load was already called')
			if ('Valid' in this)
			{
				$$(_ + '1.2 - If we got error previously then report it again.')
				if (!this.Valid)
					throw this.Error;
			}

			$$(_ + '1.3 - Identify the remaining members to Syntax Assistant')
			Identify("LUA", ["Valid", "Error"]);

			$$(_ + '1.4 - Initialize \'Valid\' to false')
			this.Valid = false;
			this.Pushers = new Map();

			for (const fmt of ["d>s", "d>d", "dd>d", "dd>s"])
			{
				$$(_ + `1.5 - Find '${fmt}' & save it's PUSH instruction`)
				const addr = Exe.FindText(fmt, false);
				if (addr > 0)
					this.Pushers.set(fmt, PUSH(addr));
			}

			$$(_ + '1.6 - Find \'ReqJobName\'')
			addr = Exe.FindText("ReqJobName", CASE_INSENSITIVE);
			if (addr < 0)
			{
				this.Error = new Error("LUA - 'ReqJobName' not found");
				throw this.Error;
			}

			$$(_ + '1.7 - Save the address as well as PUSH "ReqJobName" instruction')
			this.ReqJN = addr;
			this.PushRJN = PUSH(addr);

			$$(_ + '2.1 - Find where \'ReqJobName\' is used in a PUSH')
			addr = Exe.FindHex(this.PushRJN);
			if (addr < 0)
			{
				this.Error = new Error("LUA - 'ReqJobName' not used");
				throw this.Error;
			}

			$$(_ + '2.2 - Find the ESP allocation before the PUSH')
			let code =
				SUB(ESP, WC)	//sub esp, immA
			+	MOV(ECX, ESP)   //mov ecx, esp
			;
			let movAddr = Exe.FindHex(code, addr - 0x28, addr);
			if (movAddr < 0)
			{
				this.Error = new Error("LUA - ESP allocation not found");
				throw this.Error;
			}

			$$(_ + '2.3 - Save the constant used in SUB ESP')
			this.StkConst = Exe.GetInt8(movAddr + 2);

			$$(_ + '2.4 - Retrieve the instruction after the PUSH')
			let ins = Instr.FromAddr(addr + 5);

			$$(_ + '3 - Extract & assign based on the opcode')
			switch (ins.Codes[0])
			{
				case 0xE8:
					$$(_ + '3.1 - For DIRECT call (seen in VC6). Save the target address as \'Allocator\' & set the type to Regular')

					this.Allocator = Exe.GetTgtAddr(ins.NextAddr - 4);
					this.Al_Mode = FnMode.Regular;
					break;

				case 0xFF:
					$$(_ + '3.2 - For INDIRECT call (seen in VC9). Save the pointer address as \'Allocator\' & set the type to Ptr')

					if (ins.MRM.RegO !== 2) //ensuring its a CALL dword ptr
					{
						this.Error = new Error("LUA - 0xFF seen after PUSH 'ReqJobName', but not a CALL");
						throw this.Error;
					}

					this.Allocator = ins.Disp;
					this.Al_Mode = FnMode.Ptr;
					break;

				case 0xC6:
					$$(_ + '3.3 - For Zero Init DIRECT call (seen in VC10+). Save the target address as \'Allocator\' & set the type to ZInit')

					ins.moveToNext();
					if (ins.Codes[0] !== 0xE8) // Ensure the next instruction is a direct CALL
					{
						this.Error = new Error("LUA - No direct call found after Zero Init");
						throw this.Error;
					}
					this.Allocator = Exe.GetTgtAddr(ins.NextAddr - 4);
					this.Al_Mode = FnMode.ZInit;
					break;

				default:
					this.Error = new Error("LUA - Unexpected instruction after PUSH 'ReqJobName'");
					throw this.Error;
			}

			$$(_ + '4.1 - Find the GlobLuaState assignment (different code for different linker) after the instruction')
			code =
				Exe.BuildDate < 20100300 ? MOV(EAX, [POS3WC]) :
				Exe.Version < 11.0       ? MOV(R32, [POS3WC]) :
				                           PUSH([POS4WC]) ;

			addr = Exe.FindHex(code, ins.NextAddr, ins.NextAddr + 0x10);
			if (addr < 0)
			{
				this.Error = new Error("LUA - global state assignment missing");
				throw this.Error;
			}

			$$(_ + '4.2 - Extract the GlobLuaState address & save it as a PUSH dword ptr')
			ins = Instr.FromAddr(addr);
			this.PushState = PUSH( [ins.Disp] );

			$$(_ + '4.3 - Find the CALL after the assignment (this is lua function invoker)')
			addr = Exe.FindHex( CALL(NEG3WC), ins.NextAddr, ins.NextAddr + 0x10 );
			if (addr < 0 && Exe.BuildDate > 20190000)
			{
				addr = Exe.FindHex( CALL(POS3WC), ins.NextAddr, ins.NextAddr + 0x10 );
			}
			if (addr < 0)
			{
				this.Error = new Error("LUA - function invoker missing");
				throw this.Error;
			}

			$$(_ + '4.4 - Save the function address.')
			this.FnInvoker = Exe.GetTgtAddr(addr + 1);

			$$(_ + '5.1 - Find the string "Lua Files\\DataInfo\\jobName"')
			addr = Exe.FindText("Lua Files\\DataInfo\\jobName", CASE_INSENSITIVE);
			if (addr < 0)
			{
				this.Error = new Error("LUA - jobName string missing");
				throw this.Error;
			}

			$$(_ + '5.2 - Find where it is used in a PUSH. Should be followed by a CALL')
			addr = Exe.FindHex( PUSH(addr) + CALL() );
			if (addr < 0)
			{
				this.Error = new Error("LUA - jobName not used");
				throw this.Error;
			}

			$$(_ + '5.3 - Find the GlobLuaState movement to ECX before the PUSH')
			movAddr = Exe.FindHex( MOV(ECX, [ESI, POS2WC]), addr - 10, addr); //mov ecx, dword ptr [esi + dispA]
			if (movAddr < 0)
				movAddr = Exe.FindHex( MOV(ECX, [POS3WC]), addr - 10, addr);  //mov ecx, dword ptr [dispA]

			if (movAddr < 0)
			{
				this.Error = new Error("LUA - global state movement missing for FileLoader");
				throw this.Error;
			}

			$$(_ + '5.4 - Extract the function address')
			this.FileLoader = Exe.GetTgtAddr(addr + 6);

			$$(_ + '5.5 - Extract the MOV ECX')
			this.FL_movECX = Instr.FromAddr(movAddr).toString();

			$$(_ + '5.6 - Set validity to true')
			this.Valid = true;
		},

		///
		/// \brief Creates and returns code for calling a Lua function inside the loaded executable
		///
		createCaller : function(name, format)
		{
			const _ = "LUA.createCaller : ";

			$$(_ + '1.1 - Sanity Check (Ensure we have a valid object)')
			if ('Valid' in this === false)
				throw Error("LUA not loaded");

			if (!this.Valid)
				throw this.Error;

			$$(_ + '1.2 - Select the appropriate PUSH instruction based on the format')
			let PUSH_fmt;
			if (IsArr(format)) //format is provided as [string, stringAddr]
			{
				PUSH_fmt = PUSH(format[1]);
				format = format[0];
			}
			else if (this.Pushers.has(format))
			{
				PUSH_fmt = this.Pushers.get(format);
			}
			else
				throw Error("LUA - Unknown format specified");


			$$(_ + '1.3 - Calculate the number of arguments for input & output')
			const [icnt, ocnt] = format.split(">").map(e => e.length);

			$$(_ + '1.4 - Split up the inputs & outputs')
			const inputs = Array.prototype.slice.call(arguments, 2, 2 + icnt).reverse();
			const outputs = Array.prototype.slice.call(arguments, 2 + icnt, 2 + icnt + ocnt).reverse();

			$$(_ + '2 - Now we construct the code in stages')
			let pre = this.Al_Mode === FnMode.Regular ? PUSH(name.length) : '';
			let code = '', suf = '';


			$$(_ + '2.1 - First we prepare stack locations for the outputs & PUSH them')
			if (ocnt > 0)
			{
				pre += SUB(ESP, 4 * ocnt);         //sub esp, immA ; enough for all the outputs

				code +=
					ocnt === 1
				?
					PUSH(ESP)                       //push esp; for 1 output
				:                                   //  OR
					MOV(ECX, ESP)                   //mov ecx, esp
				+	(PUSH(ECX)                      //push ecx     ; repeated n-1 times
				+	ADD(ECX, 4)).repeat(ocnt - 1)   //add ecx, 4   ; repeated n-1 times
				+	PUSH(ECX)                       //push ecx
				;
			}

			$$(_ + '2.2 - PUSH all the inputs in reverse order')
			for (const arg of inputs)
				code += PUSH(arg); //PUSH input_arg

			$$(_ + '2.3 - PUSH the format, and prepare ECX for the allocator')
			code +=
				PUSH_fmt                         //push offset <argFormat>
			+	SUB(ESP, this.StkConst)          //sub esp, <StkConst>
			+	MOV(ECX, ESP)                    //mov ecx, esp
			;

			$$(_ + '2.4 - PUSH the function name along with additional argument and CALL the Allocator')
			switch (this.Al_Mode)
			{
				case FnMode.ZInit :
					code +=
						PUSH(name.length)        //push <funcNameLength>
					+	PUSH(Filler(50))         //push offset <funcName>
					+	MOV([ECX, 0x14], 0xF)    //mov dword ptr [ecx + 14h], 0f
					+	MOV([ECX, 0x10], 0x0)    //MOV dword ptr [ecx + 10h], 0
					+	MOV(BYTE_PTR, [ECX], 0)  //mov byte ptr [ecx], 0
					+	CALL(Filler(51))         //call Allocator
					;
					break;

				case FnMode.Ptr :
					code +=
						PUSH(Filler(50))         //push offset <funcName>
					+	CALL([this.Allocator])   //call dword ptr [Allocator]
					;
					break;

				case FnMode.Regular :
					code +=
						LEA(EAX, [ESP, this.StkConst + 4 * (icnt + ocnt + 2)]) //lea eax, [esp + StkConst + constL]; contains funcName length
					+	PUSH_EAX                 //push eax
					+	PUSH(Filler(50))         //push offset <funcName>
					+	CALL(Filler(51))         //call Allocator
					;
					break;
			}

			$$(_ + '2.5 - PUSH the state and Call the FnInvoker')
			code +=
				this.PushState                   //push dword ptr [GlobLuaState]
			+	CALL(Filler(52))                 //call FnInvoker
			+	ADD(ESP, this.StkConst + 8 + 4*icnt)  //add esp, StkConst + 8 + constI
			;

			$$(_ + '2.6 - Retrieve the outputs')
			if (ocnt > 0)
			{
				for (const arg of outputs)
				{
					code +=
						POP(ECX)                 //pop ecx
					+	(IsArr(arg)
					?
						MOV(ECX, [ECX])          //mov ecx, dword ptr [ecx]
					+	MOV(arg, ECX)            //mov outputPtr, ecx
					:                            //  OR
						MOV(arg, [ECX])          //mov outputReg, dword ptr [ecx]
					)
					;
				}

				$$(_ + '2.7 - Restore the stack')
				suf = ADD(ESP, 4 * ocnt +                     //add esp, (immA + 4)  for Regular CALL
					(this.Al_Mode === FnMode.Regular ? 4 : 0)
				);
			}

			$$(_ + '3 - Return the codes created')
			return [pre, code, suf];
		},

		///
		/// \brief Replace all the Fillers to finalize the code created with createCaller function
		///
		finalize(code, at, nameAddr)
		{
			if (IsArr(code))
				code = code.join('');

			if (IsStr(nameAddr))
				nameAddr = Exe.FindText(nameAddr, CASE_INSENSITIVE, false);

			if (nameAddr)
				code = SwapFillers( code, {50: nameAddr} );

			code = SetFillTargets( code, {
				'start': at,
				    51 : this.Allocator,
				    52 : this.FnInvoker
			});

			return code;
		},

		///
		/// \brief Adds code for loading lua files at specified target address
		///
		addLoaders : function(arg1, arg2, arg3, arg4)
		{
			/// 0 - Parse the arguments
			let files, refName, tgt, skipOrig = false;

			const loadNewFirst = IsArr(arg1);
			if (loadNewFirst)
			{
				files = arg1;
				refName = arg2;
			}
			else
			{
				files = arg2;
				refName = arg1;
			}

			if (IsBool(arg3))
			{
				skipOrig = arg3;
				tgt = arg4;
			}
			else
			{
				tgt = arg3;
			}
			if (!IsNum(tgt))
				tgt = -1;

			const _ = "LUA.addLoaders : ";

			$$(_ + '1.1 - Sanity Check (Ensure we have a valid object)')
			if ('Valid' in this === false)
				throw Error("LUA not loaded");

			if (!this.Valid)
				throw this.Error;

			$$(_ + '1.2 - Find the string inside refName')
			const refAddr = Exe.FindText(refName, CASE_INSENSITIVE);
			if (refAddr < 0)
				throw Error("LUA.addLoaders - Reference file (" + refName + ") missing");

			$$(_ + '1.3 - Find where its used in a PUSH (it should be immediately followed by a CALL)')
			let addr = Exe.FindHex( PUSH(refAddr) + CALL() );
			if (addr < 0)
				throw Error("LUA.addLoaders - Reference file not used");

			$$(_ + '1.4 - Find the ECX movement right before it')
			let hookAddr = Exe.FindHex(this.FL_movECX, addr - 10, addr);
			if (hookAddr < 0)
				hookAddr = Exe.FindHex(MOV(ECX, [POS4WC]), addr - 10, addr); //mov ecx, dword ptr [GlobLuaState]

			if (hookAddr < 0)
				throw Error("LUA.addLoaders - ECX assignment missing");

			$$(_ + '1.5 - Save the location after the CALL')
			const retnPhy = addr + 10;
			const retnVir = Exe.Phy2Vir(retnPhy, CODE);

			$$(_ + '2.1 - Prepare the template to use for each file & save its size')
			const template =
				Exe.GetHex(hookAddr, addr - hookAddr)  //prep code
			+	PUSH(Filler(1))                        //push offset <filePrefix>
			+	CALL(Filler(2))                        //call CLua::Load
			;
			const tsize = template.byteCount();

			$$(_ + '2.2 - Calculate total code size')
			const csize = tsize * (files.length + (skipOrig ? 0 : 1)) + 7; //5 for the JMP at the end and 2 NULL bytes for seperation between code and strings

			$$(_ + '2.3 - Prepare the strings to be appended at the end of the code')
			const strings = files.join('\x00').toHex() + ' 00';
			const ssize = strings.byteCount();

			$$(_ + '2.4 - Save the VIRTUAL address (If no address is specified then allocate space for it)')
			let tgtVir;
			if (tgt > 0)
				tgtVir = Exe.Phy2Vir(tgt);
			else
				[tgt, tgtVir] = Exe.FindSpace(csize + ssize, 0x10); //snapping to 0x10 since its going to be like a function

			$$(_ + '3.1 - Initialize the code variable, set the initial CALL distance and address of first string')
			let code = "";
			let dist = this.FileLoader - (tgtVir + tsize);
			let strAddr = tgtVir + csize;

			$$(_ + '3.2 - If the original file needs to be loaded first then first add the entry for that using the template')
			if (!skipOrig && !loadNewFirst)
			{
				code += SwapFillers( template, 1,
				{
					1 : refAddr,
					2 : dist,
				});

				dist -= tsize;
			}

			for (const file of files)
			{
				$$(_ + '3.3 - Fill the template with the string address & distance and append to the code (' + file + ')')
				code += SwapFillers( template, 1,
				{
					1 : strAddr,
					2 : dist,
				});

				$$(_ + '3.4 - Update the strAddr to the next string location')
				strAddr += file.length + 1;

				$$(_ + '3.5 - Update the distance for the next CALL')
				dist -= tsize;
			};

			$$(_ + '3.6 - If the original file needs to be loaded last then add the entry for that using the template')
			if (!skipOrig && loadNewFirst)
			{
				code += SwapFillers( template, 1, {
					1 : refAddr,
					2 : dist,
				});
			}

			$$(_ + '3.7 - Append the JMP at the end along with the 2 NULLs')
			code += JMP(retnVir, tgtVir + csize - 7) + " 00 00";

			$$(_ + '4.1 - Add the code & strings to the executable')
			Exe.AddHex(tgt, code + strings, csize + ssize);

			$$(_ + '4.2 - Enforce a JMP from hookAddr to target (NOP out all code in between)')
			Exe.SetJMP(hookAddr, tgtVir, retnPhy - (hookAddr + 5));

			$$(_ + '4.3 - Return the target address')
			return tgt;
		},
	};
}

///
/// \brief Initialize when Exe is loaded (only load the object in relevant patches)
///
LUA.init();
