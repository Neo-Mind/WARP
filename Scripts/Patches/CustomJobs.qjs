/**************************************************************************\
*                                                                          *
*   Copyright (C) 2013-2022 Neo-Mind                                       *
*                                                                          *
*   This file is a part of WARP project (specific to RO clients)           *
*                                                                          *
*   WARP is free software: you can redistribute it and/or modify           *
*   it under the terms of the GNU General Public License as published by   *
*   the Free Software Foundation, either version 3 of the License, or      *
*   (at your option) any later version.                                    *
*                                                                          *
*   This program is distributed in the hope that it will be useful,        *
*   but WITHOUT ANY WARRANTY; without even the implied warranty of         *
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          *
*   GNU General Public License for more details.                           *
*                                                                          *
*   You should have received a copy of the GNU General Public License      *
*   along with this program.  If not, see <http://www.gnu.org/licenses/>.  *
*                                                                          *
*                                                                          *
|**************************************************************************|
*                                                                          *
*   Author(s)     : Neo-Mind                                               *
*   Created Date  : 2021-03-19                                             *
*   Last Modified : 2022-08-23                                             *
*                                                                          *
\**************************************************************************/

///
/// \brief: Change the Hardcoded loading & retrieval of Job strings (Name, Path prefix,
///         Hand prefix, Palette prefix & Imf Prefix?) to use Lua functions.
///         Similarly update the sprite size checker & Mount retrieval functions as well.
///
CustomJobs = function()
{
	const _ = 'CustomJobs : ';

	$$(_ + '1.1 - Ensure the \'Translate Taekwon\' patch is unselected. Not applicable for test mode')
	if (!Warp.TestMode)
		Warp.SetPatchState("TranslateTaekwon", false);

	//=====================================================//
	// Find the table loading area (references to strings) //
	//=====================================================//

	if (!CACHE.has('CJ_Infos'))
	{
		let refs = [];

		$$(_ + '1.2 - Find the spr/act path suffix for Santa costume')
		let strAddr = Exe.FindText("\xBB\xEA\xC5\xB8");
		if (strAddr < 0)
			throw Error("Santa is missing");

		$$(_ + '1.3 - Find it\'s references (there should only be 1) and add to "refs" array')
		let addrs = Exe.FindHexN(MOV([R32, 0x68], strAddr)); //mov dword ptr [regA + 68h], offset "»êÅ¸"
		if (ROC.IsZero && addrs.length > 1)
		{
			const addr = addrs.find( memAddr =>
				Exe.FindLastHex(PUSH(0x10AA) + MOV(ECX, ESI), memAddr, memAddr - 0x800) < 0
			);
			if (!addr)
				throw Error("Santa reference missing");

			refs[0] = addr;
		}
		else if (addrs.length === 1)
		{
			refs[0] = addrs[0];
		}
		else
		{
			throw Error("Unexpected no of Santa references");
		}

		$$(_ + '1.4 - Find the imf suffix for Groom/Bride (used for Santa as well) and add to "refs" array')
		strAddr = Exe.FindText("\xB0\xE1\xC8\xA5"); //"°áÈ¥"
		if (strAddr < 0)
			throw Error("Groom/Bride is missing");

		addrs = Exe.FindHexN(1, 1, MOV([R32, 0x68], strAddr)); //mov dword ptr [regA + 68h], offset "°áÈ¥"
		if (addrs.isEmpty())
			throw Error("Expected exactly 1 Wedding reference");

		refs[1] = addrs[0];

		$$(_ + '1.5 - Find the palette suffix for Archer')
		strAddr = Exe.FindText("\xB1\xC3\xBC\xF6"); //"±Ã¼ö"
		if (strAddr < 0)
			throw Error("Archer is missing");

		if (Exe.Version === 6)
		{
			$$(_ + '1.6 - For VC6 find it\'s reference after a PUSH 4')
			addrs = Exe.FindHexN(MOV([EAX], strAddr) + CALL()); // mov dword ptr [eax], offset "±Ã¼ö"
																// call <fetcher>

			const code2 = PUSH(4); //PUSH 4 should be present before

			const addr = addrs.find( memAddr =>
				Exe.FindLastHex(code2, memAddr, memAddr - 0x6) > 0
			);
			if (!addr)
				throw Error("Archer reference missing (VC6)");

			refs[2] = addr;
		}
		else
		{
			$$(_ + '1.7 - For VC9+ find all references with direct movement to table')
			addrs = Exe.FindHexN(MOV([R32, 0xC], strAddr)); //mov dword ptr [regA + 0Ch], offset "±Ã¼ö"

			const addr = addrs.find( memAddr =>
				!refs.some(refAddr => memAddr >= (refAddr - 0x300) && memAddr <= (refAddr + 0x300))
			);
			if (!addr)
				throw Error("Archer reference missing (VC9+)");

			refs[2] = addr;
		}

		$$(_ + '1.8 - Find the hand prefix for Archer')
		strAddr = Exe.FindText("\xB1\xC3\xBC\xF6\\\xB1\xC3\xBC\xF6"); // ±Ã¼ö\±Ã¼ö for Archer
		if (strAddr < 0)
			throw Error("Hand prefix missing");

		$$(_ + '1.9- Find it\'s reference')
		refs[3] = Exe.FindHex(MOV([R32, 0xC], strAddr)); //mov dword ptr [regA + 0Ch], offset "±Ã¼ö\±Ã¼ö"
		if (refs[3] < 0)
			throw Error("Hand reference missing");

		$$(_ + '1.10 - Find the name for Acolyte (ok that sounds weird)')
		strAddr = Exe.FindText("Acolyte"); //We use Acolyte here because Archer has a ( mov ecx, offset ) instruction before it in Older clients
		if (strAddr < 0)
			throw Error("Acolyte is missing");

		$$(_ + '1.11 - Find it\'s reference')
		refs[4] = Exe.FindHex(MOV([R32, 0x10], strAddr)); //mov dword ptr [regA + 10h], offset "Acolyte"
		if (refs[4] < 0)
			throw Error("Acolyte reference missing");

		//==========================================================================================//
		// Find the hook & end address for table loading & extract all non-related codes in between //
		//==========================================================================================//

		$$(_ + '2.1 - Ensure LANGTYPE is loaded . Needed by FetchTillEnd')
		LANGTYPE.load();

		let limits = Exe.BuildDate >= 20170700
		? [
			0x6D93,
			0x6D93,
			0x6D93,
			0x6D93,
			0x7D01
		]
		: [
			0x524C,
			0x524C,
			0x524C,
			0x524C,
			0x61BA
		]
		;

		let fetcher = -1;
		const infos = refs.map( (addr, idx) =>
		{
			$$(_ + '2.2 - Prep variables for required info')
			let hookAddr, movIns, baseReg, format; //baseReg contains address for index 0 of the table, movIns will contain the mov to baseReg

			$$(_ + '2.3 - Find the limit usage before it')
			const limitAddr = Exe.FindLastHex(limits[idx].toHex(), addr, addr - 0x800);
			if (limitAddr < 0)
				throw Error(`Limit missing for no.${idx + 1}`);

			$$(_ + '2.4 - Extract the instruction after the reference')
			let ins = Instr.FromAddr(addr).moveToNext();
			if (ins.Codes[0] === 0xE8) //VC6
			{
				$$(_ + '2.5 - Since there is no mov unset movIns')
				movIns = null;

				$$(_ + '2.6 - Calculate the CALL\'s address if not already found')
				if (fetcher < 0)
					fetcher = Exe.Phy2Vir(ins.NextAddr, CODE) + ins.Immd; //the target VIRTUAL address

				$$(_ + '2.7 - Find the address for the first table assignment')
				const code =
					PUSH_0         //push 0
				+	MOV(ECX, ESI)  //mov ecx, esi
				+	CALL(ALLWC)    //call func#1
				;
				const firstAddr = Exe.FindHex(code, limitAddr + 4, limitAddr + 0x60);
				if (firstAddr < 0)
					throw Error(`First index assignment missing for no.${idx + 1}`);

				$$(_ + '2.8 - Set the hook address after the CALL & set the base register')
				hookAddr = firstAddr + code.byteCount();
				baseReg = EAX;
				format = 0;
			}
			else if (ins.Codes[0] === 0x8B && ins.MRM.Mode !== 3) //VC9+
			{
				$$(_ + '2.9 - Set it as the mov instruction')
				movIns = ins;

				$$(_ + '2.10 - Extract the register used as source in mov tgtReg, dword ptr [srcReg + Disp]')
				const srcReg = ins.MRM.getReg('M');

				$$(_ + '2.11 - Use it to construct the table assignment pattern & look for it after the limitAddr')
				const prefix = MOV(R32, ins.Disp ? [srcReg, ins.Disp] : [srcReg]);
				const addrs = [
					...Exe.FindHexN(1, prefix + MOV([R32], POS3WC), limitAddr + 4, limitAddr + 0x60),        //mov dword ptr [regA], offset#1
					...Exe.FindHexN(1, prefix + MOV([R32, WCp], POS3WC), limitAddr + 4, limitAddr + 0x60),   //mov dword ptr [regA + disp8], offset#1
					...Exe.FindHexN(1, prefix + MOV([R32, POS2WC], POS3WC), limitAddr + 4, limitAddr + 0x60) //mov dword ptr [regA + disp32], offset#1
				].sort();

				if (addrs.isEmpty())
					throw Error(`Starting index assignment missing for no.${idx + 1}`);

				$$(_ + '2.12 - Hook at the location after the smallest')
				hookAddr = addrs[0] + movIns.Size;

				$$(_ + '2.13 - Use the next byte to calculate the base register')
				baseReg = R32.List[Exe.GetInt8(hookAddr + 1) & 0x7];
				format = 1;
			}
			else
				throw Error(`Unexpected opcode for no.${idx + 1}`);

			$$(_ + '3.1 - Now find the ending instruction while extracting all relevant instructions (not related to table loading) in between')
			let [endIns, retainer, overflow] = FetchTillEnd(hookAddr, format, movIns, baseReg, fetcher, (ins) =>
			{
				if (Exe.Version === 6) //VC6
				{
					switch (ins.Codes[0])
					{
						case 0x8D:
							if (ins.MRM.Mode === 2) //lea regA, [regB + dispB]
							{
								return (Exe.GetUint16(ins.NextAddr) === 0x45C7); //followed by ( mov dword ptr [LOCAL.x], offset#1 )
							}
							else if (ins.MRM.Mode === 1) //lea regA, [LOCAL.y]
							{
								let bytes = Exe.GetUint16(ins.NextAddr);

								return (bytes === 0xB38D || //followed by ( add regA, immA )
										bytes === 0xC381 || //or by       ( lea regA, [regB + dispB] )
										bytes === 0x5588 ); //or by       ( mov byte ptr [LOCAL.x], dl )
							}
							break;

						case 0x8B: //mov eax, dword ptr [edi+4]
							return (ins.MRM.Data === 0x47 && ins.Disp === 4);
					}
				}
				else if (Exe.Version <= 10) //VC9 & VC10
				{
					switch (ins.Codes[0])
					{
						case 0x2B: //sub regA, regB
							return (ins.MRM.Mode === 3 && (Exe.GetInt32(ins.Addr + 2) & 0xFFF8FF) === 0x02F8C1); //followed by ( sar regA, 2 )

						case 0x83: //or regA, -1
							return (ins.MRM.RegO === 1 && ins.Immd === -1);

						case 0xFF: //call dword ptr [funcPtr#1] //hopefully wont conflict later
							return (ins.MRM.Data === 0x15);
					}
				}
				else //VC11+
				{
					switch (ins.Codes[0])
					{
						case 0x8D:
							if (ins.MRM.Mode === 1 && ins.MRM.RegO === 0 && Exe.GetUint8(ins.NextAddr) === 0x50) //lea eax, [LOCAL.x]
							{                                                                                    //push eax
								let opcode = Exe.GetUint8(ins.NextAddr + 1);

								return (opcode === 0x6A || //followed by ( push immA )
										opcode === 0x68 ||
										opcode === 0x56 ); //or by ( push esi )
							}
							break;

						case 0x8B:
							if (ins.MRM.Mode === 0 && ins.MRM.RegO === 0) //mov eax, dword ptr [regA]
							{
								return (Exe.GetUint16(ins.NextAddr) === 0x048D); //followed by ( lea eax, [regB*4 + eax] )
							}
							break;

						case 0xE8: //stop at the CALL
							return true;
					}
				}
				return false;
			});
			if (overflow)
				throw Error(`Table end missing for no.${idx+1}`);

			$$(_ + '3.2 - Return the set')
			return [hookAddr, baseReg, endIns, retainer];
		});

		CACHE.put('CJ_Infos', infos);
	}

	$$(_ + '4.1 - Get the new max limit from user')
	const MaxJob = Exe.GetUserInput('$maxJob', D_Uint16, "Limit Input", "Enter the maximum no of Job IDs", 4400, {min: 4400, max: 5000, saveDefault: true});
	if (MaxJob === false)
		Cancel("No Max Limit specified");

	//====================================//
	// Add the Function Names into client //
	//====================================//

	$$(_ + '4.2 - Insert the Lua function names into the client (Since we wont be using the hardcoded JobNames, we will overwrite suitable ones and use their addresses)')
	const ReqFuncs =
	[
		this.overwrite("Professor",     "ReqPCPath"    ),
		this.overwrite("Swordman",      "ReqPCImf"     ),
		this.overwrite("Magician",      "ReqPCPal"     ),
		this.overwrite("Swordman High", "ReqPCHandPath"),
		this.overwrite("Baby Acolyte",  "ReqPCJobName" ),
	];
	const MapFuncs =
	[
		this.overwrite("Whitesmith",    "MapPCPath"    ),
		this.overwrite("Assassin",      "MapPCImf"     ),
		this.overwrite("Crusader",      "MapPCPal"     ),
		this.overwrite("Magician High", "MapPCHandPath"),
		this.overwrite("High Wizard_W", "MapPCJobName" ),
	];
	const AltFuncs =
	[
		this.overwrite("High Priest_W", "GetPCNameOvrd"),
		this.overwrite("Alchemist",     "GetHalter"    ),
		this.overwrite("Acolyte",       "IsDwarf"      ),
		this.overwrite("High Wizard",   "GetSprScale"  ),
	];

	$$(_ + '4.3 - Get the stored infos')
	const infos = CACHE.get('CJ_Infos');

	//=======================================//
	// Add Table Loaders using LUA functions //
	//=======================================//

	$$(_ + '5.1 - Ensure LUA object is loaded')
	LUA.load();

	let fileHookAddr, //location where the file loading code will be placed
	    ddd2sAddr;    //location for the "ddd>s" format string
	[
		"PCPath",
		"PCImf",
		"PCPal",
		"PCHandPath",
		"PCJobName"
	].forEach( (fnSuffix, index) =>
	{
		$$(_ + `5.2 - Setup the limits for ${fnSuffix}`)
		const reductor = (index === 4) ? 0 : 3950;
		const limits =
		[
			[0, 0x2C],
			[0xFA1 - reductor, MaxJob - reductor]
		];

		$$(_ + '5.3 - Generate the templates first')
		const templates = this.generate(
			[["Req" + fnSuffix, ReqFuncs[index]], "dd>s", EDI, [LANGTYPE], EAX],
			index === 4 //PCJobName
		?
			null //dont call Map for JobName since it is done later anyways (avoid redundancy)
		:
			[["Map" + fnSuffix, MapFuncs[index]], "dd>d", EDI, [LANGTYPE], EAX]
		,
			[ESP, 0x24]
		);

		$$(_ + '5.4 - Retrieve the info for this index')
		const [hookAddr, baseReg, endIns, retainer] = infos[index];

		$$(_ + '5.5 - Combine & construct the replacement code in parts')
		let parts =
		[
			PUSH(baseReg)  //push <baseReg> ; contains address of first index in table
		+	PUSHAD         //pushad
		];

		for (const template of templates)
		{
			for (const [min, max] of limits)
			{
				parts.push( SwapFillers( template,
				{
					1 : min,
					2 : max
				}));
			}
		}

		parts.push(
			POPAD            //popad
		+	ADD(ESP, 4)      //add esp, 4
		);

		if (retainer)
			parts.push(retainer); //codes to be retained from original

		if (endIns)
			parts.push(JMP(Filler(3))); //jmp endAddr ; address of endIns

		$$(_ + '4.6 - Fill in the blanks')
		let code = LUA.finalize(parts, Exe.Phy2Vir(hookAddr, CODE),
		{
			3 : endIns ? Exe.Phy2Vir(endIns.Addr, CODE) : ''
		});

		$$(_ + '4.7 - Replace at hook address')
		Exe.SetHex(hookAddr, code);

		if (index === 4)
		{
			$$(_ + '4.8 - Save the location afterwards to use for file loading (picked name table loader since it is the largest)')
			fileHookAddr = hookAddr + code.byteCount();
		}
	});

	//=========================//
	// Inject Lua file loading //
	//=========================//

	$$(_ + '4.9 - Use the address found earlier to add code for loading the files')
	LUA.addLoaders(
		[
			"Lua Files\\JobInfo\\PCIds",
			"Lua Files\\JobInfo\\PCPaths",
			"Lua Files\\JobInfo\\PCImfs",
			"Lua Files\\JobInfo\\PCHands",
			"Lua Files\\JobInfo\\PCPals",
			"Lua Files\\JobInfo\\PCNames",
			"Lua Files\\JobInfo\\PCFuncs"
		],
		"Lua Files\\DataInfo\\NPCIdentity",
		fileHookAddr
	);

	//============================================================================//
    // Find Gender based Name assignment & Setup extra table assignment for names //
    //============================================================================//

	limits =
	[
		[0, 0x2C],
		[0xFA1, MaxJob]
	];

	$$(_ + '5.1 - Find \'TaeKwon Girl\'')
	const tgAddr = Exe.FindText("TaeKwon Girl");
	if (tgAddr < 0)
		throw Error("'TaeKwon Girl' not found");

	if (Exe.BuildDate < 20190800 || (!ROC.IsRenewal && Exe.BuildDate < 20190810)) //Older form - Seperate function is called each time the character selection changes
	{
		$$(_ + '5.2 - Find where it\'s referenced')
		let parts;
		if (Exe.Version < 11)
		{
			parts =
			[
				TEST(EAX, EAX)          //test eax, eax
			+	JNZ(WCp)                //jnz short _skip
			,
				MOV(Exe.Version === 9 && Exe.BuildDate < 20110300 ? R32 : EAX, [POS4WC]) //mov regA, dword ptr [g_jobName]
			,
				MOV([R32, 0x3F38], tgAddr)  //mov dword ptr [regA + 3F38h], offset "TaeKwon Girl"
			];
		}
		else if (Exe.BuildDate < 20170000)
		{
			parts =
			[
				''
			,
				MOV(EAX, [POS4WC])      //mov eax, dword ptr [g_jobName]
			,
				MOV(R32, tgAddr)        //mov regB, offset "TaeKwon Girl"
			+	MOV(R32, POS4WC)        //mov regC, offset "TaeKwon Boy"
			+	CMOVNZ(R32, R32)        //cmovnz regC, regB
			+	MOV([EAX, 0x3F38], R32) //mov dword ptr [eax + 3F38h], regC
			];
		}
		else
		{
			parts =
			[
				TEST(R32, R32)          //test regA, regA
			+	(Exe.Version > 11
			?
				MOV(R32, POS4WC)        //mov regC, offset "TaeKwon Boy"
			:
				''
			)
			+	MOV(R32, tgAddr)        //mov regB, offset "TaeKwon Girl"

			+	CMOVNZ(R32, R32)        //cmovnz regC, regB
			,
				MOV(EAX, [POS4WC])      //mov eax, dword ptr [g_jobName]
			,
				POP_R                   //pop regD
			+	MOV([EAX, 0x3F38], R32)	//mov dword ptr [eax + 3F38h], regC
			];
		}

		let addr = Exe.FindHex(parts);
		if (addr < 0)
			throw Error("'TaeKwon Girl' not assigned");

		$$(_ + '5.3 - Extract the g_jobName address')
		const JobName = Instr.FromAddr(addr + parts.byteCount(0)).Disp;

		$$(_ + '5.4 - Look for the LANGTYPE comparison before it (in fact the JNZ should jump to a call after which we do the above TEST)')
		///       (These steps are also done in TranslateClient but we will keep it anyways as a failsafe)
		let code;
		if (Exe.Version >= 9 && Exe.BuildDate < 20170000)
		{
			code =
				CMP([LANGTYPE], 0)     //cmp dword ptr [g_serviceType], 0
			+	MOV(ECX, POS3WC)       //mov ecx, offset#1
			+	JNE(WCp)               //jne short _skip
			;
		}
		else
		{
			code =
				MOV(EAX, [LANGTYPE])   //mov eax, dword ptr [g_serviceType]
			+	(Exe.Version === 6
			?
				MOV(ECX, POS3WC)       //mov ecx, offset#1
			:
				''
			)
			+	TEST(EAX, EAX)         //test eax, eax
			+	JNZ(WCp)               //jnz short _skip
			;
		}
		addr = Exe.FindHex(code, addr - 0xA0, addr);
		if (addr < 0)
			throw Error("Langtype Comparison missing");

		$$(_ + '5.5 - Enforce the conditional jump')
		addr += code.byteCount();
		Exe.SetJMP(addr - 2);

		$$(_ + '5.6 - Go to the target address of the jump (serves as the hookAddr)')
		let hookAddr = addr + Exe.GetInt8(addr - 1);

		$$(_ + '5.7 - Extract the instruction there & check the opcode to extract info for the next step')
		let genderReg, endAddr, pushes;
		let ins = Instr.FromAddr(hookAddr);
		if (ins.Codes[0] === 0xE8)
		{
			$$(_ + '5.8 - If the instruction at the address is CALL CSession::GetSex then EAX will have the gender value.')
			genderReg = EAX;
			hookAddr += 5;

			$$(_ + '5.9 - Find the LANGTYPE comparison after the address')
			code =
				CMP(EAX, 0xC) //cmp eax, 0Ch
			+	JE(WCp)       //je short _idxInc
			+	CMP(EAX, 5)   //cmp eax, 5
			+	JE(WCp)       //je short _idxInc

			+	(Exe.Version > 11.0
			?
				CMP(EAX, 0xE) //cmp eax, 0Eh
			+	JE(WCp)       //je short _idxInc
			:
				''
			)
			+	CMP(EAX, 6)   //cmp eax, 6
			;

			addr = Exe.FindHex(code, hookAddr + 0x10, hookAddr + 0x100);
			if (addr < 0)
				throw Error("2nd Langtype Comparison missing");

			$$(_ + '5.10 - Extract the previous 2 bytes and test for PUSH reg instructions')
			pushes = Exe.GetBytes(addr - 2, 2);

			if (pushes[0] < 0x50 || pushes[0] > 0x57)
				pushes[0] = 0x90;

			if (pushes[1] < 0x50 || pushes[1] > 0x57)
				pushes[1] = pushes[0] === 0x90 ? 0x56 : 0x90;

			$$(_ + '5.11 - Goto the address after the last comparison (should be a JNE)')
			addr += code.byteCount();

			$$(_ + '5.12 - Goto the target address of the JNE')
			ins = Instr.FromAddr(addr);
			if (ins.Codes[0] === 0x75 || ins.Codes[1] === 0x85)
				addr = ins.NextAddr + ins.Immd;
			else
				throw Error("Expected JNE but it's missing");

			$$(_ + '5.14 - Check for the second JNE after 3 bytes (CMP EAX, 0A) and retrieve it\'s target PHYSICAL address')
			if (Exe.GetUint16(addr + 3) === 0x850F)
				endAddr = Exe.GetTgtAddr(addr + 5);
			else
				throw Error("2nd JNE missing");
		}
		else if (ins.Codes[0] === 0x83 && ins.MRM.Data === 0xF8) //newer clients (2017+)
		{
			$$(_ + '5.15 - The comparison is at the address itself, which means the gender was provided as argument and assigned to EDI earlier')
			genderReg = EDI;
			pushes = [];
		}
		else
		{
			throw Error("Unexpected instruction found");
		}

		$$(_ + '5.16 - Generate the templates to be used')
		const templates = this.generate(
			[["GetPCNameOvrd", AltFuncs[0]], "ddd>s", EDI, ESI, [LANGTYPE], EAX],
			[["MapPCJobName",  MapFuncs[4]], "dd>d",  EDI, [LANGTYPE], EAX],
			[JobName]
		);

		$$(_ + '5.17 - Construct the code in parts')
		parts = pushes.map(opcode => opcode.toHex(1)); //set of PUSH reg32 which need to be retained since they are POPed out later

		parts.push(
			PUSHAD
		+	MOV(ESI, genderReg)
		);

		for (const template of templates)
		{
			for (const [min, max] of limits)
			{
				parts.push( SwapFillers( template,
				{
					1 : min,
					2 : max
				}));
			}
		}

		parts.push(
			POPAD                //popad
		);

		if (endAddr)
		{
			parts.push(JMP(Filler(3))); //jmp <endAddr>
		}
		else
		{
			parts.push(
				POP(EDI)         //pop edi
			+	POP(EBP)         //pop ebp
			+	RETN(4)          //retn 4
			);
		}

		$$(_ + '5.18 - Fill in the blanks')
		const hookVir = Exe.Phy2Vir(hookAddr, CODE);

		code = LUA.finalize( parts, hookVir,
		{
			3 : endAddr
		});

		$$(_ + '5.19 - Replace at hook address')
		Exe.SetHex(hookAddr, code);
	}
	else //Newer form - Name overrides are setup along with the regular loading and it uses a seperate function for it
	{
		$$(_ + '6.1 - Retrieve the address after the ending instruction for the name table loading (ideally would be a CALL)')
		const [,,endIns] = infos.last();
		const hookAddr = endIns.NextAddr;

		$$(_ + '6.2 - Find the ECX assignment after it')
		let addr = Exe.FindHex(LEA(ECX, [EBX, POS2WC]), hookAddr, hookAddr + 0x30); //lea ecx, [ebx + dispA]

		if (addr < 0 && Exe.BuildDate > 20210000)
			addr = Exe.FindHex(MOV(ECX, EDI), hookAddr, hookAddr + 0x30);

		if (addr < 0)
			throw Error("Object assignment missing");
		
		$$(_ + '6.3 - Save the instruction')
		const ecxAssign = Instr.FromAddr(addr);

		$$(_ + '6.4 - Find the table assignment before hookAddr')
		addr = Exe.FindLastHex( MOV(R32, [R32]) + MOV([R32, POS2WC], POS4WC), hookAddr, hookAddr - 0x100);
		if (addr < 0)
			throw Error("Table assignment missing");

		$$(_ + '6.5 - Extract the memory register used')
		const tblReg = Instr.FromAddr(addr).MRM.getReg('M');

		$$(_ + '6.6 - Find the string assignment to stack location')
		addr = Exe.FindHex(MOV([EBP, WCn], tgAddr), hookAddr, hookAddr + 0x90);  //mov dword ptr [LOCAL.x], offset "TaeKwon Girl"
		if (addr < 0)
			throw Error("Taekwon girl not referenced");

		$$(_ + '6.7 - Save the stack location used')
		const strLoc = [EBP, Instr.FromAddr(addr).Disp];

		$$(_ + '6.8 - Find the index assignment to stack location')
		addr = Exe.FindHex(MOV([EBP, WCn], 0xFD2), hookAddr, hookAddr + 0x90); //mov dword ptr [LOCAL.x], 0FD2h
		if (addr < 0)
			throw Error("Index PUSH missing");

		$$(_ + '6.9 - Save the stack location used')
		const idxLoc = [EBP, Instr.FromAddr(addr).Disp];

		$$(_ + '6.10 - Find the additional stack location PUSH after it (not sure why it is needed)')
		let parts =
		[
			LEA(EAX, [EBP, WCn]) //lea eax, [LOCAL.y]
		,
			''
		,
			PUSH_EAX             //push eax
		];

		let addr2 = Exe.FindHex(parts, addr + 8, hookAddr + 0x30);
		if (addr2 < 0)
		{
			parts[1] = ecxAssign.toString();
			addr2 = Exe.FindHex(parts, addr + 8, hookAddr + 0x30);
		}
		const csize = parts.byteCount();

		if (addr2 > 0)
		{
			const disp = Instr.FromAddr(addr2).Disp;
			if (disp === idxLoc[1] || disp === strLoc[1]) //this is the wrong PUSH, so search again
				addr2 = Exe.FindHex(parts, addr2 + csize, hookAddr + 0x30);
		}
		if (addr2 < 0)
			throw Error("Mem PUSH missing");

		$$(_ + '6.11 - Save the instructions')
		const pushMEM = Exe.GetHex(addr2, parts.byteCount(0)) + PUSH_EAX;

		$$(_ + '6.12 - Look for the function CALL after the PUSH (either its directly after or the LEA is in between)')
		addr = addr2 + csize;
		if (addr === ecxAssign.Addr)
			addr = ecxAssign.NextAddr;

		let ins = Instr.FromAddr(addr);
		if (ins.Codes[0] !== 0xE8) //a mov dword ptr instruction can also come in between
			ins.moveToNext();

		if (ins.Codes[0] !== 0xE8)
			throw Error("Function CALL missing");

		$$(_ + '6.14 - Retrieve the target VIRTUAL address')
		const Overrider = Exe.Phy2Vir(ins.NextAddr + ins.Immd, CODE);

		$$(_ + '6.15 - Find the ending address of the table')
		addr = Exe.FindHex(MOV(R32, 0x2D) + NOP2, addr + 0x200, addr + (Exe.BuildDate > 20211000 ? 0x1000 : 0x400));
		if (addr < 0)
			throw Error("Ending address missing for new overrides");

		const endVir = Exe.Phy2Vir(addr, CODE);

		$$(_ + '6.16 - Construct the template (the first one need to be done manually since the way we code is different)')
		const templates = this.generate(
			null,
			[["MapPCJobName", MapFuncs[4]], "dd>d", EDI, [LANGTYPE], EAX],
			[ESP, 0x24]
		);

		const [    , mainM,        ] = LUA.createCaller(["GetPCNameOvrd", AltFuncs[0]], "ddd>s", EDI, 1, [LANGTYPE], EAX);
		const [prep, mainF, restore] = LUA.createCaller(["GetPCNameOvrd", AltFuncs[0]], "ddd>s", EDI, 0, [LANGTYPE], EAX);

		parts =
		[//0
			MOV(EDI, Filler(1))      //mov edi, <startingValue> ; serves as idx
		+	MOV(ESI, Filler(2))      //mov esi, <endingValue>
		+	prep                     //Stack Prep

		,//1
			mainM                    //LUA function caller for Male ; _loop
		+	MOV(CL, [EAX])           //mov cl, dword ptr [eax]
		+	TEST(CL, CL)             //test cl, cl
		+	JE(7)                    //je short _skip
		+	MOV(ECX, [ESP, 0x24])    //mov ecx, dword ptr [esp+24h] ; table address
		+	MOV([4, EDI, ECX], EAX)  //mov dword ptr [4*edi + ecx], eax

		+	mainF                    //LUA function caller for Female ; _skip
		+	MOV(CL, [EAX])           //mov cl, dword ptr [eax]
		+	TEST(CL, CL)             //test cl, cl
		+	JE(Filler(6,1))          //je short _idxInc
		+	MOV(strLoc, EAX)         //mov dword ptr [LOCAL.z], eax

		+	MOV(ECX, [ESP, 0x28])    //mov dword ptr ecx, [esp+28h] ; object address
		+   PUSH_EAX                 //push eax   ; the name
		+	LEA(EAX, idxLoc)         //lea eax, [LOCAL.x]
		+	MOV([EAX], EDI)          //mov dword ptr [eax], edi
		+	PUSH_EAX                 //push eax   ; the index location
		+	PUSH_0                   //push 0
		+	pushMEM                  //lea eax, [LOCAL.y]
			                         //push eax   ; the mem location
		+	CALL(Filler(4))          //call <Overrider>

		,//2
			INC(EDI)                 //inc edi ; _idxInc
		+	CMP(EDI, ESI)            //cmp edi, esi
		+	JLE(Filler(5))           //jle _loop ; to start of the first 'main' code i.e. mainM
		+	restore                  //Stack restore
		];

		const [,_loop, _idxInc] = MapAddrs(0, parts);

		templates[0] = SetFillTargets( parts, 1,
		{
			 5    : _loop,
			'6,1' : _idxInc
		});

		$$(_ + '6.17 - Construct the code in parts')
		parts =
		[
			ecxAssign      //either lea OR mov to ecx
		+	PUSH(ECX)      //push ecx
		+	PUSH([tblReg]) //push dword ptr [edi] or [esi] ; table address
		+	PUSHAD         //pushad
		];

		for (const template of templates)
		{
			for (const [min, max] of limits)
			{
				parts.push( SwapFillers( template,
				{
					1 : min,
					2 : max
				}));
			}
		}

		parts.push(
			POPAD            //popad
		+	ADD(ESP, 8)      //add esp, 8
		+	JMP(Filler(3))   //jmp <endVir>
		);

		$$(_ + '6.18 - Fill in the blanks')
		const hookVir = Exe.Phy2Vir(hookAddr, CODE);

		const code = LUA.finalize(parts, hookVir,
		{
			3 : endVir,
			4 : Overrider
		});

		$$(_ + '6.19 - Replace at hook address')
		Exe.SetHex(hookAddr, code);
	}

	//============================//
    // Special Mod 1 : Cash Mount //
    //============================//

	if (Exe.BuildDate > 20101214)
	{
		$$(_ + '7.1 - Find the function whre the Mount ID is assigned')
		const code =
			CMP(EAX, 0x19)   //cmp eax, 19h
		+	JNE(WCp)         //jne short _skip
		+	MOV(EAX, 0x1012) //mov eax, 1012h
		;
		const addr = Exe.FindHex(code);
		if (addr < 0)
			throw Error("Mount assignment missing");

		$$(_ + '7.2 - Construct the LUA caller code')
		const [prep, main, restore] = LUA.createCaller(["GetHalter", AltFuncs[1]], "d>d", EAX, EAX);

		$$(_ + '7.3 - Replace at the address')
		Exe.SetHex( addr
		,
			LUA.finalize(
				PUSH(EDX)  //Backup EDX
			+	prep       //Stack Prep
			+	main       //LUA function CALL
			+	restore    //Stack Restore
			+	POP(EDX)   //Restore EDX
			+	(ROC.HasFP
			?
				POP(EBP)   //pop ebp
			:
				''
			)
			+	RETN(4)    //retn 4
			,
				Exe.Phy2Vir(addr, CODE)
			)
		);
	}

    //================================================//
    // Special Mod 2 : Baby Jobs (Tester & Shrink) //
    //================================================//

	$$(_ + '8.1 - Identify the style based on dates')
	const style =
		         Exe.Version > 11 ? 1:
		Exe.BuildDate >= 20180314 ? 2:
		Exe.BuildDate >= 20110600 ? 3:
		                            4;

	let shrinkAddrs;
	if (style < 4)
	{
		$$(_ + '8.2 - Find the common signature')
		let reg = Exe.Version > 10 ? R32 : EAX;
		const prefix = MOV(reg, [ROC.StkReg, ROC.HasFP ? 8 : 4]); //mov regA, dword ptr [ARG.1]
		const csize = prefix.byteCount();

		const suffix =
			CMP(reg, 0xFB7)  //cmp regA, 0FB7h
		+	JL(WCp)          //jl short _nextcheck
		+	CMP(reg, 0xFBD)  //cmp regA, 0FBDh
		;

		const minCount = style === 1 ? 2 : 1;
		const maxCount = style === 1 ? 3 : 1;
		const addrs = Exe.FindHexN(minCount, maxCount, prefix + suffix);
		if (addrs.isEmpty())
			throw Error("Expected no of matches not found");

		let testerAddr;
		if (style === 1)
		{
			$$(_ + '8.3 - Identify each based on whether retn 4 followed by same suffix is there within same function')
			for (const memAddr of addrs)
			{
				if (Exe.FindHex(RETN(4) + suffix, memAddr + 0x10, memAddr + 0x100) > 0)
					shrinkAddrs = [memAddr + csize];
				else
					testerAddr = memAddr + csize;
			}
		}
		else //style 2 or 3
		{
			$$(_ + '8.4 - For 2nd form, only one match would be there for the tester function')
			testerAddr = addrs[0] + csize;
		}

		$$(_ + '8.5 - If the register isnt EAX find the one that was used')
		if (reg.isPlaceHolder())
			reg = R32.List[Exe.GetInt8(testerAddr + 1) & 0x7];

		$$(_ + '8.6 - Construct the LUA caller code for Dwarf test')
		const luaCaller = LUA.createCaller(["IsDwarf", AltFuncs[2]], "d>d", reg, EAX).join('');

		$$(_ + '8.7 - Replace at the address')
		Exe.SetHex( testerAddr
		,
			LUA.finalize(
				PUSH(EDX)  //push edx ; Backup
			+	luaCaller  //LUA function CALL
			+	POP(EDX)   //pop edx ; Restore it
			+	(ROC.HasFP
			?
				POP(EBP)   //pop ebp
			:
				''
			)
			+	RETN(4)    //retn 4
			,
				Exe.Phy2Vir(testerAddr, CODE)
			)
		);
	}

	if (!shrinkAddrs)
	{
		if (style > 2)
		{
			$$(_ + '8.8 - Find the older form of the patterns')
			const code =
				CMP(EAX, 0xFB7)  //cmp eax, 0FB7h
			+	JL(WCp)          //jl short _nextcheck
			+	MOV(ECX, R32)    //mov ecx, regB
			+	CALL(ALLWC)      //call CSession::GetJobID
			+	CMP(EAX, 0xFBD)  //cmp eax, 0FBDh
			;

			shrinkAddrs = Exe.FindHexN(1, 3, code);
			if (shrinkAddrs.isEmpty())
				throw Error("Expected no of shrinking code not found");
		}
		else if (style === 2)
		{
			$$(_ + '8.9 - For 2nd style use the retn to find the correct function')
			let code =
				RETN(4)          //retn 4
			+	CMP(R32, 0xFB7)  //cmp regA, 0FB7h
			+	JL(WCp)          //jl short _nextcheck
			+	CMP(R32, 0xFBD)  //cmp regA, 0FBDh
			;
			let addr = Exe.FindHex(code);
			if (addr < 0)
				throw Error("Reference pattern missing");

			$$(_ + '8.10 - Now trace back to the beginning where the Dwarf test function is called')
			code =
				PUSH(ESI)     //push esi
			+	CALL(ALLWC)   //call <IsDwarf>
			+	TEST(AL, AL)  //test al, al
			+	JZ(WCp)       //jz short _proceed
			;
			addr = Exe.FindLastHex(code, addr, addr - 0x100);
			if (addr < 0)
				throw Error("Shrinking function missing");

			shrinkAddrs = [addr];
		}
	}

	$$(_ + '8.11 - Setup space to store the scale value')
	const [, scaleAddr] = Exe.AddInt32(0);

	const found = shrinkAddrs.filter( (shrinkAddr, idx) =>
	{
		const __ = `${_} [${idx}] `;

		$$(__ + '9.1 - Deduce the register containing the Job id')
		const reg =
			style > 2   ? EAX :
			style === 2 ? ESI :
			              R32.List[Exe.GetUint8(shrinkAddr + 1) & 0x7];

		$$(__ + '9.2 - Use it to create the LUA function Calling code')
		const luaCaller = LUA.createCaller(["GetSprScale", AltFuncs[3]], "d>d", reg, [scaleAddr]).join('');

		if (style > 2) //Individual comparisons
		{
			$$(__ + '9.3 - Ensure there is a JLE after comparison with FBD')
			const addr = Exe.FindHex(CMP(EAX, 0xFBD), shrinkAddr);
			const ins = Instr.FromAddr(addr + 5);
			if (ins.Codes[0] !== 0x7E && ins.Codes[1] !== 0x8E)
				return false;

			$$(__ + '9.4 - Extract the instruction at the address. It would be either an FLD DWORD PTR or MOVSS XMM0, DWORD PTR')
			const tgtLoader = ins.getNext(ins.Immd);

			$$(__ + '9.5 - Extract the instruction after it. Would be a FMUL dword ptr or MULSS XMM0, DWORD PTR')
			let multiplier = tgtLoader.getNext();

			$$(__ + '9.6 - Save the next address (if it\'s a JMP go to it\'s target instead)')
			let endAddr = multiplier.NextAddr;
			if (Exe.GetUint8(endAddr) === 0xEB)
				endAddr += Exe.GetInt8(endAddr + 1) + 2;

			$$(__ + '9.7 - Modify the multiplier code to ensure dword ptr is used and use the scaleAddr as displacement')
			if (multiplier.Codes[0] === 0xDC)
				multiplier.Codes[0] = 0xD8;

			multiplier.Disp = scaleAddr;

			$$(__ + '9.8 - Construct the code to replace with')
			let code =
				PUSHAD                //pushad ; backup registers
			+	luaCaller             //Code which calls the lua function to get the scale
			+	POPAD                 //popad  ; restore registers

			+	tgtLoader             //fld/movss xmm0, dword ptr [LOCAL.x]
			+	MOV(EAX, [scaleAddr]) //mov eax, dword ptr [scaleAddr]
			+	TEST(EAX, EAX)        //test eax, eax
			+	JZ(multiplier.Size)   //jz short _skipover
			+	multiplier            //fmul/mulss xmm0, dword ptr [eax]
			;
			const csize = code.byteCount();

			$$(__ + '9.9 - Ensure there is enough space for the code')
			if ((endAddr - shrinkAddr) > (csize + 2))
			{
				$$(__ + '9.10 - Append the NOPs/Short JMP to the end of the code')
				const delta = endAddr - shrinkAddr - csize;
				code +=
					delta > 0x12
				?
					JMP(delta, 0)    //jmp short <endAddr>
				:                    //   OR
					NOPs(delta)      //multibyte NOPs
				;

				$$(__ + '9.11 - Replace at the address')
				Exe.SetHex(shrinkAddr, LUA.finalize(code, Exe.Phy2Vir(shrinkAddr, CODE)));
			}
			else
			{
				$$(__ + '9.12 - Append the JMP')
				code +=
					JMP(Filler(1)) //jmp <endAddr>
				;
				
				$$(__ + '9.14 - Prepare the arguments for auto-hook')
				const args =
				{
					allocSize : csize + 5,
					postProc : LUA.finalize,
					procArgs : {1 : Exe.Phy2Vir(endAddr, CODE)} //serves as 3rd argument to postProc
				};

				$$(_ + '9.15 - Add our code and jump to it from shrinkAddr')
				AutoHook(shrinkAddr, code, args);
			}
		}
		else //seperate function return after FLD
		{
			$$(__ + '9.17 - Construct the new function')
			const code =
				PUSHAD                //pushad ; backup registers
			+	luaCaller             //Code which calls the lua function to get the scale
			+	POPAD                 //popad  ; restore registers

			+	MOV(EAX, [scaleAddr]) //mov eax, dword ptr [scaleAddr]
			+	TEST(EAX, EAX)        //test eax, eax
			+	JNZ(7)                //jnz short _idxInc
			+	FLD1                  //fld1
			+	POP(reg)              //pop regA
			+	POP(EBP)              //pop ebp
			+	RETN(4)               //retn 4
			+	FLD([scaleAddr])      //fld dword ptr [scaleAddr]
			+	POP(reg)              //pop regA
			+	POP(EBP)              //pop ebp
			+	RETN(4)               //retn 4
			;

			$$(__ + '9.18 - Replace at shrinkAddr')
			Exe.SetHex(shrinkAddr, LUA.finalize(code, Exe.Phy2Vir(shrinkAddr, CODE)));
		}

		return true;
	});

	if (found.isEmpty())
		throw Error("Shrinking address not found");

	$$(_ + '10 - Check with user if they want to copy the supporting files to the target area\'s data folder')
	if (!Warp.TestMode)
		Exe.GetUserInput('$copyCJLub', D_Bool, "Copy Custom Job Lua", "Do you want the supporting Lub files copied to <b>'data'</b> folder when patch is applied?", true);

	return true;
};

///
/// \brief Disable for unsupported clients
///
CustomJobs.validate = IsPost2010;

///
/// \brief Extra steps when the patch is applied (Copy the Lua files if requested)
///
CustomJobs.onApplied = function()
{
	const _ = 'CustomJobs.onApplied : ';

	if (!Warp.TestMode && Exe.GetSavedInput('$copyCJLub'))
	{
		$$(_ + '1.1 - Prepare the directory paths')
		const suffix = "/Luafiles514/Lua Files/JobInfo";
		const srcDir = Warp.Path + "Inputs" + suffix;
		let tgtDir = System.DirPath(Warp.TgtExe) + "/data" + suffix;

		$$(_ + '1.2 - For old clients the version prefix is not there')
		if (Exe.BuildDate < 20120000)
			tgtDir = tgtDir.replace("LuaFiles514/", '');

		$$(_ + '1.3 - Create the target directory')
		const ready = System.MkDir(tgtDir);
		if (!ready)
			return;

		$$(_ + '2 - Copy all the lua files to the target directory')
		for (const prefix of
		[
			"PCIds",
			"PCPaths",
			"PCImfs",
			"PCHands",
			"PCPals",
			"PCNames",
			"PCFuncs"
		])
			System.Copy(srcDir + "/" + prefix + ".lub", tgtDir);
	}
};

///
/// \brief Helper function to replace the string with new function name and return it's VIRTUAL address
///
CustomJobs.overwrite = (oldStr, newStr) =>
{
	const _ = 'CustomJobs.overwrite : ';

	$$(_ + `1 - Find the old string '${oldStr}'`)
	const addr = Exe.FindText(oldStr, PHYSICAL);
	if (addr < 0)
		throw Error(`${oldStr} not found`);

	$$(_ + '2 - Replace with the new one')
	Exe.SetText(addr, newStr  + "\x00");

	$$(_ + '3 - Return it\'s VIRTUAL address')
	return Exe.Phy2Vir(addr);
};

///
/// \brief Helper function to generate the templates for Req/Get function & Map function
///
CustomJobs.generate = (firstSet, secondSet, memPtr) =>
{
	const _ = 'CustomJobs.generate : ';

	$$(_ + '1 - Prepare the common parts')
	const cmnPre =
		MOV(EDI, Filler(1))      //mov edi, startingValue ; serves as idx
	+	MOV(EBX, Filler(2))      //mov ebx, endingValue
	;

	const cmnSuf =
		(memPtr.length > 1 ? NOP2 : '') //add extra NOPs to accomodate for [esp + 24h] mem location
	+	MOV([4, EDI, ECX], EAX)  //mov dword ptr [edi*4 + ecx], eax
	+	INC(EDI)                 //inc edi ; _idxInc
	+	CMP(EDI, EBX)            //cmp edi, ebx
	;

	$$(_ + '2 - Construct the templates in parts')
	const templates = [
		firstSet,
		secondSet
	].map( (args, idx) =>
	{
		if (!args)
			return '';

		const [prep, main, restore] = LUA.createCaller(...args); ///feed the arguments to createCaller

		const prefix =
			cmnPre                    //edi & ebx assignment
		+	prep                      //Stack Prep
		;

		const infix =
			main                     //LUA caller code
		+	(idx === 0

		? //for Req/Get
			MOV(CL, [EAX])            //mov cl, byte ptr [EAX]
		+	TEST(CL, CL)              //test cl, cl
		+	JE(9)                     //je short _idxInc
		+	MOV(ECX, memPtr)          //mov ecx, dword ptr [memPtr]; //either direct address or ESP+24 ; 20 = 8 registers * 4 due to PUSHAD + 4 for the starting memory address which was PUSHed before the PUSHAD

		: //for Map
			TEST(EAX, EAX)            //test eax, eax
		+	JS(0xC)                   //js short _idxInc
		+	MOV(ECX, memPtr)          //mov ecx, dword ptr [memPtr] ;
		+	MOV(EAX, [4, EAX, ECX])   //mov eax, dword ptr [eax*4 + ecx]
		)
		+	cmnSuf                    //table assignment, EDI increment & comparison for loop
		;

		const csize = infix.byteCount();

		const suffix =
			JLE(-csize, 0)            //jle short _loop OR jle _loop ; to start of the 'main' code
		+	restore                   //Stack Restore
		;

		return (prefix + infix + suffix);
	});

	$$(_ + '3 - Return the array')
	return templates;
};
